<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《A Grammar-Based Structural CNN Decoder for Code Generation》阅读笔记"><meta name="keywords" content="NLP,Code Generation,Semantic Parsing,CNN"><meta name="author" content="yym6472"><meta name="copyright" content="yym6472"><title>《A Grammar-Based Structural CNN Decoder for Code Generation》阅读笔记 | yym6472's Blog</title><link rel="shortcut icon" href="/favicon-256.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"G2KYQO0W55","apiKey":"f8377236a1dbdcb6cfe6bcce269cbc82","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#本文要解决的问题"><span class="toc-number">1.</span> <span class="toc-text"> 本文要解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关工作"><span class="toc-number">2.</span> <span class="toc-text"> 相关工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本文提出的模型"><span class="toc-number">3.</span> <span class="toc-text"> 本文提出的模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于语法规则的代码生成"><span class="toc-number">3.1.</span> <span class="toc-text"> 基于语法规则的代码生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用cnn编码输入的代码描述"><span class="toc-number">3.2.</span> <span class="toc-text"> 使用CNN编码输入的代码描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用cnn编码之前时间步预测的语法规则"><span class="toc-number">3.3.</span> <span class="toc-text"> 使用CNN编码之前时间步预测的语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用cnn编码预测中的抽象语法树"><span class="toc-number">3.4.</span> <span class="toc-text"> 使用CNN编码预测中的抽象语法树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基于树形结构的cnn"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 基于树形结构的CNN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对树结点进行前序遍历的cnn"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 对树结点进行前序遍历的CNN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#树路径的cnn"><span class="toc-number">3.4.3.</span> <span class="toc-text"> 树路径的CNN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于池化和注意力的聚合"><span class="toc-number">3.5.</span> <span class="toc-text"> 基于池化和注意力的聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模型训练"><span class="toc-number">3.6.</span> <span class="toc-text"> 模型训练</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实验一hearthstone代码生成数据集"><span class="toc-number">4.</span> <span class="toc-text"> 实验一：HearthStone代码生成数据集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据集"><span class="toc-number">4.1.</span> <span class="toc-text"> 数据集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价指标"><span class="toc-number">4.2.</span> <span class="toc-text"> 评价指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实验结果"><span class="toc-number">4.3.</span> <span class="toc-text"> 实验结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实验二语义分析"><span class="toc-number">5.</span> <span class="toc-text"> 实验二：语义分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据集-2"><span class="toc-number">5.1.</span> <span class="toc-text"> 数据集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实验结果-2"><span class="toc-number">5.2.</span> <span class="toc-text"> 实验结果</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2019/04/27/5cc4218c74e0e.jpg"></div><div class="author-info__name text-center">yym6472</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/yym6472">Follow Me on GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">18</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">25</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com/">MARKSZのBlog (Theme Auther's Blog)</a><a class="author-info-links__name text-center" href="https://pris-nlp.github.io/">BUPT PRIS Lab, NLP Group</a><a class="author-info-links__name text-center" href="https://helicqin.github.io/">Helicqin's Blog</a><a class="author-info-links__name text-center" href="https://hexo.io/">Hexo</a><a class="author-info-links__name text-center" href="https://apexmeister.github.io/">ApEx&amp;mOmOcO's Lofter</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/04/27/5cc456373162f.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">yym6472's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a><a class="site-page" href="/contact">Contact</a></span></div><div id="post-info"><div id="post-title">《A Grammar-Based Structural CNN Decoder for Code Generation》阅读笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/学习/">学习</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/学习/论文阅读笔记/">论文阅读笔记</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.8k</span><span class="post-meta__separator">|</span><span>Reading time: 9 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Conference from: AAAI 2019</p>
<p>Paper link: <a href="https://kami.app/xSULuBEhbzlZ" target="_blank" rel="noopener">[KAMI]</a> <a href="https://www.aaai.org/ojs/index.php/AAAI/article/view/4686/4564" target="_blank" rel="noopener">[PDF]</a></p>
<p>Code: <a href="https://github.com/zysszy/GrammarCNN" target="_blank" rel="noopener">https://github.com/zysszy/GrammarCNN</a></p>
<a id="more"></a>
<h2 id="本文要解决的问题"><a class="markdownIt-Anchor" href="#本文要解决的问题"></a> 本文要解决的问题</h2>
<p>本文拟解决的是代码生成（Code Generation）的任务，即：给定一段自然语言描述，模型自动生成代码片段。例如：给定描述“open the file, F1”，期望模型能自动生成Python代码：<code>f = open('F1', 'r')</code>。</p>
<p>与往常的使用RNN建模不同，本文使用CNN来提取输入特征。作者认为代码片段比传统的自然语言句子更长，因此RNN难以捕获长期依赖；而CNN能够通过滑动窗口捕捉到各个区域的特征，同时CNN具有效率高（可并行训练）、易收敛等特性。</p>
<p>作者提出本文是第一个成功地（完全）采用CNN来做代码生成任务的工作。</p>
<h2 id="相关工作"><a class="markdownIt-Anchor" href="#相关工作"></a> 相关工作</h2>
<p>传统地，代码生成任务被视为是seq2seq任务，使用encoder-decoder结构进行建模，编码器和解码器一般由RNN担任，输入自然语言形式的代码描述序列，输出代码序列。然而，用seq2seq模型建模代码生成任务，忽略了重要的结构信息（例如语法规则的约束），因此生成的代码可能存在语法错误。</p>
<p>为了解决上述问题，研究者们提出了基于抽象语法树（AST）的代码生成。这种方式通过不断预测要展开文法符号所应该采用的规则，依托于树的结构递归地生成程序的抽象语法树，继而获得可执行程序。与上述的seq2seq的代码生成不同，这类方法生成的代码保证了在语法上的正确性。</p>
<p>本文提出的方法就是基于语法规则的代码生成（Python2语法规则表见：<a href="https://docs.python.org/2/library/ast.html" target="_blank" rel="noopener">https://docs.python.org/2/library/ast.html</a>）。</p>
<h2 id="本文提出的模型"><a class="markdownIt-Anchor" href="#本文提出的模型"></a> 本文提出的模型</h2>
<p><img src="https://i.loli.net/2019/09/19/KRgEwQfGHtJ7Zlc.png" alt="模型结构图"></p>
<p>上图给出了本文的模型结构图，其中左半部分为使用CNN对各个输入进行特征的提取；右半部分为使用注意力（attention）和池化（pooling）对特征进行融合。下面对其逐一进行介绍。</p>
<h3 id="基于语法规则的代码生成"><a class="markdownIt-Anchor" href="#基于语法规则的代码生成"></a> 基于语法规则的代码生成</h3>
<p>该方法即对抽象语法树（AST）进行前序遍历，每次决定使用哪一条文法规则展开一个结点。模型采用自回归（autoregressiveness）的方法构建，即在之前预测的基础上预测下一个要展开的规则。每一个样本的输入为：</p>
<ul>
<li>代码描述信息</li>
<li>之前时间步预测的规则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>r</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[r_1, r_2, ..., r_{n-1}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li>
<li>当前生成的（部分）抽象语法树</li>
<li>当前要展开的结点的位于抽象语法树中的位置</li>
</ul>
<p>在这些输入的基础上决定展开当前时间步结点采用的语法规则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">r_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<h3 id="使用cnn编码输入的代码描述"><a class="markdownIt-Anchor" href="#使用cnn编码输入的代码描述"></a> 使用CNN编码输入的代码描述</h3>
<p>对于<a href="https://github.com/deepmind/card2code/tree/master/third_party/hearthstone" target="_blank" rel="noopener">HearthStone代码生成数据集</a>来说，输入（代码描述）是一个半结构化的信息，包括了这张卡牌的名字、属性、描述等，如下图（a）所示，而生成的代码如下图（b）所示。</p>
<p><img src="https://i.loli.net/2019/09/19/eNjvg6Aku3zbJV9.png" alt="HearthStone数据集样例"></p>
<p>首先作者将输入的卡牌描述分词，转换为一个token的序列，然后使用word embeddings将其编码成向量序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="bold-italic">x</mi><mn>1</mn><mrow><mo>(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mo>)</mo></mrow></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msubsup><mi mathvariant="bold-italic">x</mi><mi>I</mi><mrow><mo>(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\boldsymbol{x}_1^{(enc)}, ..., \boldsymbol{x}_I^{(enc)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.338331em;vertical-align:-0.29353099999999993em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.433692em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4064690000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29353099999999993em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>是输入token序列的长度。随后采用一系列堆叠的卷积层来提取特征，得到特征表示序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="bold-italic">y</mi><mn>1</mn><mrow><mo>(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mo separator="true">,</mo><mi>L</mi><mo>)</mo></mrow></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msubsup><mi mathvariant="bold-italic">y</mi><mi>I</mi><mrow><mo>(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mo separator="true">,</mo><mi>L</mi><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\boldsymbol{y}_1^{(enc,L)}, ..., \boldsymbol{y}_I^{(enc,L)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.338331em;vertical-align:-0.29353099999999993em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.433692em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">L</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4064690000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">L</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29353099999999993em;"><span></span></span></span></span></span></span></span></span></span>。层与层之间采用了ResNet中提出的残差连接（shortcut connections），公式如下：<br>
<img src="https://i.loli.net/2019/09/19/lghtO53mkevMyEB.png" alt="卷积层计算公式"><br>
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mrow><mo>(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mo separator="true">,</mo><mi>l</mi><mo>)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(enc,l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>是卷积核参数；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mo>(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">s=(k-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>计算，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>为窗口大小（在实验中采用2）；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">l=1, ..., L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span></span></span></span>为深度CNN的层数编号。特别的，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="bold-italic">y</mi><mi>i</mi><mrow><mo>(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\boldsymbol{y}_i^{(enc,0)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.321664em;vertical-align:-0.27686399999999994em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span></span>就是输入的embedding <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="bold-italic">x</mi><mi>i</mi><mrow><mo>(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\boldsymbol{x}_i^{(enc)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.321664em;vertical-align:-0.27686399999999994em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span></span>；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>c</mi><mrow><mo>(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mo separator="true">,</mo><mi>l</mi><mo>)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">c^{(enc,l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>表示是否在层级间使用残差连接，对于偶数卷积层，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>c</mi><mrow><mo>(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mo separator="true">,</mo><mi>l</mi><mo>)</mo></mrow></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c^{(enc,l)}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，对于奇数卷积层则为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。对前几个和后几个token，使用zero padding。</p>
<h3 id="使用cnn编码之前时间步预测的语法规则"><a class="markdownIt-Anchor" href="#使用cnn编码之前时间步预测的语法规则"></a> 使用CNN编码之前时间步预测的语法规则</h3>
<p>由于是自回归（autoregressiveness）模型，因此需要将之前已经预测出来的语法规则、语法树同样作为特征输入模型（就如同多轮对话中的context一般）。</p>
<p>首先作者将这些语法规则使用embeddings编码，映射成一组向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold-italic">r</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi mathvariant="bold-italic">r</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\boldsymbol{r}_1, ..., \boldsymbol{r}_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.652771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03194em;">r</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03194em;">r</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>序列，这个embedding矩阵是随机初始化并且随模型联合训练的。</p>
<p>随后，使用深度CNN来提取出特征<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="bold-italic">y</mi><mn>1</mn><mrow><mo>(</mo><mi>r</mi><mi>u</mi><mi>l</mi><mi>e</mi><mo separator="true">,</mo><mi>L</mi><mo>)</mo></mrow></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msubsup><mi mathvariant="bold-italic">y</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mo>(</mo><mi>n</mi><mi>u</mi><mi>l</mi><mi>e</mi><mo separator="true">,</mo><mi>L</mi><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\boldsymbol{y}_1^{(rule,L)}, ..., \boldsymbol{y}_{n-1}^{(nule,L)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3694389999999999em;vertical-align:-0.3246389999999999em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.433692em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">L</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.433692em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">L</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3246389999999999em;"><span></span></span></span></span></span></span></span></span></span>，计算方法同上面的(2)式一样。</p>
<h3 id="使用cnn编码预测中的抽象语法树"><a class="markdownIt-Anchor" href="#使用cnn编码预测中的抽象语法树"></a> 使用CNN编码预测中的抽象语法树</h3>
<p>尽管把预测出来的语法规则作为输入提取了特征，但这些规则是扁平的、序列化的，并不包含树形的层级结构信息，因此对于预测当前时间步的语法规则是不够的。为此，作者又使用了CNN去编码这个抽象语法树的结构。</p>
<p><img src="https://i.loli.net/2019/09/19/GrlTSYqnU8gbW7a.png" alt="针对抽象语法树的CNN"></p>
<p>上图给出了这一部分的整体示意图，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mtext>n</mtext><mstyle mathsize="0.5em"><mtext>PHD</mtext></mstyle></msub></mrow><annotation encoding="application/x-tex">\text{n}_{\text{\tiny{PHD}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">n</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.191665em;"><span style="top:-2.35em;margin-right:0.05em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord sizing reset-size3 size1"><span class="mord">P</span><span class="mord">H</span><span class="mord">D</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示当前时间步要预测的结点，它作为一个占位符，也包含在输入的抽象语法树中。具体来说，它又可以分为三个部分：</p>
<ul>
<li>基于树形结构的CNN（Tree-Based CNN）</li>
<li>对树结点进行前序遍历的CNN（Pre-Order Traversal CNN）</li>
<li>树路径的CNN（Tree-Path CNN）</li>
</ul>
<h4 id="基于树形结构的cnn"><a class="markdownIt-Anchor" href="#基于树形结构的cnn"></a> 基于树形结构的CNN</h4>
<p>首先每个结点都被编码成了一个向量。设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold-italic">n</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="bold-italic">p</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="bold-italic">g</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\boldsymbol{n}_i, \boldsymbol{p}_i, \boldsymbol{g}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68858em;vertical-align:-0.24414em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">n</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.21752399999999997em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">g</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.21752399999999997em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span>分别代表AST中的某个结点、它的父节点、它的祖父节点的向量表示，通过下面的公式，对AST中每个结点的特征进行提取：<br>
<img src="https://i.loli.net/2019/09/19/t1pSEjgewTWGYLM.png" alt="基于树形结构的CNN"><br>
其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mrow><mo>(</mo><mi>a</mi><mi>s</mi><mi>t</mi><mo>)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(ast)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>是卷积核。AST的前两层将使用一个padding，因为它们没有父节点或祖父节点。</p>
<p>作者认为对于<strong>基于语法规则的代码生成</strong>而言，当一个规则确定时，它的所有孩子结点也都确定了，对于这些孩子结点来说，其兄弟结点相当于都是确定好了的，因此作者认为兄弟结点相对来说没有父节点（以及祖父节点）重要。因此，相比之前的工作，作者扩大了向上的卷积深度而没有考虑兄弟结点。</p>
<h4 id="对树结点进行前序遍历的cnn"><a class="markdownIt-Anchor" href="#对树结点进行前序遍历的cnn"></a> 对树结点进行前序遍历的CNN</h4>
<p>上面<a href="#%E5%9F%BA%E4%BA%8E%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%9A%84CNN">基于树形结构的CNN</a>将AST中的每个结点都编码成了一个向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="bold-italic">y</mi><mi>i</mi><mrow><mo>(</mo><mi>a</mi><mi>s</mi><mi>t</mi><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\boldsymbol{y}_i^{(ast)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.321664em;vertical-align:-0.27686399999999994em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span></span>。在这一步中，作者使用一个前序遍历的方式去遍历这棵树，生成向量序列，并对在此向量序列上进行卷积操作（同公式(2)）。</p>
<p>由于前序遍历并不唯一地确定一棵树（即存在两棵前序遍历结果相同，但结构不同的树），作者将回溯过程也作为一个结点插入到输出序列，如之前的图（b）所示（橘色代表对节点的第一次访问，紫色代表回溯过程的访问）。</p>
<p>因此，卷积得到的将是一个长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>S</mi></mrow><annotation encoding="application/x-tex">2S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>的向量序列：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="bold-italic">y</mi><mn>1</mn><mrow><mo>(</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo separator="true">,</mo><mi>L</mi><mo>)</mo></mrow></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msubsup><mi mathvariant="bold-italic">y</mi><mrow><mn>2</mn><mi>S</mi></mrow><mrow><mo>(</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo separator="true">,</mo><mi>L</mi><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\boldsymbol{y}_1^{(tree,L)}, ..., \boldsymbol{y}_{2S}^{(tree,L)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.338331em;vertical-align:-0.29353099999999993em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.433692em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">L</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4064690000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">L</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29353099999999993em;"><span></span></span></span></span></span></span></span></span></span>。其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>即为AST中结点的个数。</p>
<h4 id="树路径的cnn"><a class="markdownIt-Anchor" href="#树路径的cnn"></a> 树路径的CNN</h4>
<p>考虑到<strong>当前要生成的结点在AST中的位置</strong>应该被更显式地表示出来，作者将AST根节点到当前要生成的结点（即图中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mtext>n</mtext><mstyle mathsize="0.5em"><mtext>PHD</mtext></mstyle></msub></mrow><annotation encoding="application/x-tex">\text{n}_{\text{\tiny{PHD}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">n</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.191665em;"><span style="top:-2.35em;margin-right:0.05em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord sizing reset-size3 size1"><span class="mord">P</span><span class="mord">H</span><span class="mord">D</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的路径上的所有结点表示也进行了卷积操作，生成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="bold-italic">y</mi><mn>1</mn><mrow><mo>(</mo><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo separator="true">,</mo><mi>L</mi><mo>)</mo></mrow></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msubsup><mi mathvariant="bold-italic">y</mi><mi>J</mi><mrow><mo>(</mo><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo separator="true">,</mo><mi>L</mi><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\boldsymbol{y}_1^{(path,L)}, ..., \boldsymbol{y}_J^{(path,L)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.338331em;vertical-align:-0.29353099999999993em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.433692em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">L</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">y</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4064690000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.09618em;">J</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">L</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29353099999999993em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>为卷积层数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>为路径中结点的个数。这一步同样使用公式(2)的计算方法。</p>
<h3 id="基于池化和注意力的聚合"><a class="markdownIt-Anchor" href="#基于池化和注意力的聚合"></a> 基于池化和注意力的聚合</h3>
<p>到此为止，模型获取到了四类CNN输出：</p>
<ul>
<li>enc：对程序的描述信息</li>
<li>rule：此前预测的规则</li>
<li>tree：对AST的遍历</li>
<li>path：从根节点到预测结点的路径</li>
</ul>
<p>现在要将这些特征进行融合。作者采用的是max-pooling和attention机制。首先将某些卷积特征进行池化，然后将这个池化后的向量作为query向量，与其它的卷积输出序列计算注意力权重，随后用注意力权重对卷积输出序列加权求和得到一个固定维度的向量，作为最终的向量。</p>
<p>使用何种池化、每一种特征使用何种query向量，如下图中的虚线所示：<br>
<img src="https://i.loli.net/2019/09/19/2VdNohA4yl8rKZU.png" alt="池化/注意力池化的搭配关系"><br>
这些是作者通过经验（直觉、假想、实验验证）决定的。</p>
<p>此外，作者还通过将scope（即方法名或函数名）编码后，使用它与代码描述CNN、前序遍历后的CNN进行交互。作者认为这能提供原本模型学不到的特征。当这样的scope存在多个时，作者只采用离当前最近的那一个；当这样的scope不存在时，使用零向量交互。</p>
<h3 id="模型训练"><a class="markdownIt-Anchor" href="#模型训练"></a> 模型训练</h3>
<p>最后，所有这些max-pooling和attentive-pooling的结果都被连接起来，经过一个双层的感知器，将其输出向量作为分类的logits，与ground truth的交叉熵将被作为损失进行训练。</p>
<p>在预测时，使用窗口大小为5的集束搜索，找出使得概率最大的预测序列作为最终的程序。每一步预测中，不合法的语法规则将被忽略。</p>
<h2 id="实验一hearthstone代码生成数据集"><a class="markdownIt-Anchor" href="#实验一hearthstone代码生成数据集"></a> 实验一：HearthStone代码生成数据集</h2>
<h3 id="数据集"><a class="markdownIt-Anchor" href="#数据集"></a> 数据集</h3>
<p>采用<a href="https://github.com/deepmind/card2code/tree/master/third_party/hearthstone" target="_blank" rel="noopener">HearthStone数据集</a>，其中包含炉石传说中665张不同的卡牌描述和实现其功能的代码片段（Python形式）。</p>
<h3 id="评价指标"><a class="markdownIt-Anchor" href="#评价指标"></a> 评价指标</h3>
<p>包含三个评价指标：</p>
<ul>
<li><strong>StrAcc</strong>：在字符串匹配上的准确率</li>
<li><strong>Acc+</strong>：由于模型预测出的部分代码结构正确，但部分变量名与ground truth不同，因此作者又统计了人工修正后的正确率</li>
<li><strong>BLEU</strong>：基于n-grams，作为辅助统计指标</li>
</ul>
<h3 id="实验结果"><a class="markdownIt-Anchor" href="#实验结果"></a> 实验结果</h3>
<p><img src="https://i.loli.net/2019/09/19/YcwOmZ75vrUuNpH.png" alt="实验结果及消融实验的结果"><br>
<img src="https://i.loli.net/2019/09/19/vnzKJgS1jfhcN5V.png" alt="生成的代码片段示例"><br>
具体分析见原文吧，这里懒得写了。。</p>
<h2 id="实验二语义分析"><a class="markdownIt-Anchor" href="#实验二语义分析"></a> 实验二：语义分析</h2>
<p>语义分析任务可以认为是对领域特定语言（Domain-Specific Language, DSL）进行的代码生成。作者的模型主要针对HearthStone数据集，这个实验作为扩展实验，为了验证模型的可扩展性（generalizability）。</p>
<h3 id="数据集-2"><a class="markdownIt-Anchor" href="#数据集-2"></a> 数据集</h3>
<p>作者在ATIS和JOBS两个语义分析的数据集进行实验。ATIS数据集的输出是一个λ式（λ-calculus form），如下图所示：</p>
<p><img src="https://i.loli.net/2019/09/19/USNZKBIQ7i2zWXY.png" alt="ATIS数据集输出格式"></p>
<p>而JOBS数据集的输出是Prolog风格的表达式（Prolog-style form）。</p>
<h3 id="实验结果-2"><a class="markdownIt-Anchor" href="#实验结果-2"></a> 实验结果</h3>
<p><img src="https://i.loli.net/2019/09/19/fUdPT2ZXm4C9FpJ.png" alt="扩展实验的实验结果"><br>
分析同样见原文吧。。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">yym6472</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://yym6472.github.io/2019/09/19/《A-Grammar-Based-Structural-CNN-Decoder-for-Code-Generation》阅读笔记/">https://yym6472.github.io/2019/09/19/《A-Grammar-Based-Structural-CNN-Decoder-for-Code-Generation》阅读笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NLP/">NLP</a><a class="post-meta__tags" href="/tags/Code-Generation/">Code Generation</a><a class="post-meta__tags" href="/tags/Semantic-Parsing/">Semantic Parsing</a><a class="post-meta__tags" href="/tags/CNN/">CNN</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/11/06/WordNet调研记录/"><i class="fa fa-chevron-left">  </i><span>WordNet调研记录</span></a></div><div class="next-post pull-right"><a href="/2019/09/16/《The-Neuro-Symbolic-Concept-Learner-Interpreting-Scenes-Words-and-Sentences-from-Natural-Supervision》阅读笔记/"><span>《The Neuro-Symbolic Concept Learner: Interpreting Scenes, Words, and Sentences from Natural Supervision》阅读笔记</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '1470654ab571587d5962',
  clientSecret: 'dd25cc8b92dbedf931e5a5e29b75f6bdbcff11ed',
  repo: 'yym6472.github.io',
  owner: 'yym6472',
  admin: 'yym6472',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2019/04/27/5cc456373162f.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By yym6472</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>